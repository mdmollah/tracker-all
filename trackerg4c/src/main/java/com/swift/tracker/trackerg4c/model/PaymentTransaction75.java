/*
 * gpi Corporate API
 * Move your app forward with the gpi Corporate API
 *
 * OpenAPI spec version: 2.0.2-sandbox
 * Contact: Li.JIE@swift.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */


package com.swift.tracker.trackerg4c.model;

import java.util.Objects;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.swift.tracker.trackerg4c.model.ActiveOrHistoricCurrencyAndAmount;
import com.swift.tracker.trackerg4c.model.PaymentEvent6;
import com.swift.tracker.trackerg4c.model.PaymentStatus4;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

/**
 * Contains details on the payment transaction.
 */
@ApiModel(description = "Contains details on the payment transaction.")
@javax.annotation.Generated(value = "io.swagger.codegen.languages.JavaClientCodegen", date = "2018-11-30T10:36:31.126-05:00")
public class PaymentTransaction75 {
  @SerializedName("uetr")
  private String uetr = null;

  @SerializedName("transaction_status")
  private PaymentStatus4 transactionStatus = null;

  @SerializedName("event_time")
  private String eventTime = null;

  @SerializedName("originator")
  private String originator = null;

  @SerializedName("instructed_amount")
  private ActiveOrHistoricCurrencyAndAmount instructedAmount = null;

  @SerializedName("confirmed_amount")
  private ActiveOrHistoricCurrencyAndAmount confirmedAmount = null;

  @SerializedName("payment_event")
  private List<PaymentEvent6> paymentEvent = new ArrayList<PaymentEvent6>();

  public PaymentTransaction75 uetr(String uetr) {
    this.uetr = uetr;
    return this;
  }

   /**
   * Contains the unique end to end transaction reference of a payment.
   * @return uetr
  **/
  @ApiModelProperty(required = true, value = "Contains the unique end to end transaction reference of a payment.")
  public String getUetr() {
    return uetr;
  }

  public void setUetr(String uetr) {
    this.uetr = uetr;
  }

  public PaymentTransaction75 transactionStatus(PaymentStatus4 transactionStatus) {
    this.transactionStatus = transactionStatus;
    return this;
  }

   /**
   * Specifies the status of a transaction, in a coded form.
   * @return transactionStatus
  **/
  @ApiModelProperty(required = true, value = "Specifies the status of a transaction, in a coded form.")
  public PaymentStatus4 getTransactionStatus() {
    return transactionStatus;
  }

  public void setTransactionStatus(PaymentStatus4 transactionStatus) {
    this.transactionStatus = transactionStatus;
  }

  public PaymentTransaction75 eventTime(String eventTime) {
    this.eventTime = eventTime;
    return this;
  }

   /**
   * This is the time when the related status was reached.
   * @return eventTime
  **/
  @ApiModelProperty(required = true, value = "This is the time when the related status was reached.")
  public String getEventTime() {
    return eventTime;
  }

  public void setEventTime(String eventTime) {
    this.eventTime = eventTime;
  }

  public PaymentTransaction75 originator(String originator) {
    this.originator = originator;
    return this;
  }

   /**
   * Party that issues the status.
   * @return originator
  **/
  @ApiModelProperty(required = true, value = "Party that issues the status.")
  public String getOriginator() {
    return originator;
  }

  public void setOriginator(String originator) {
    this.originator = originator;
  }

  public PaymentTransaction75 instructedAmount(ActiveOrHistoricCurrencyAndAmount instructedAmount) {
    this.instructedAmount = instructedAmount;
    return this;
  }

   /**
   * Amount of money to be moved between the debtor and creditor, before deduction of charges, expressed in the currency as ordered by the initiating party.  This amount has to be transported unchanged through the transaction chain.
   * @return instructedAmount
  **/
  @ApiModelProperty(value = "Amount of money to be moved between the debtor and creditor, before deduction of charges, expressed in the currency as ordered by the initiating party.  This amount has to be transported unchanged through the transaction chain.")
  public ActiveOrHistoricCurrencyAndAmount getInstructedAmount() {
    return instructedAmount;
  }

  public void setInstructedAmount(ActiveOrHistoricCurrencyAndAmount instructedAmount) {
    this.instructedAmount = instructedAmount;
  }

  public PaymentTransaction75 confirmedAmount(ActiveOrHistoricCurrencyAndAmount confirmedAmount) {
    this.confirmedAmount = confirmedAmount;
    return this;
  }

   /**
   * The actual amount that has been paid to the ultimate beneficiary, after all charges etc... have been deducted.
   * @return confirmedAmount
  **/
  @ApiModelProperty(value = "The actual amount that has been paid to the ultimate beneficiary, after all charges etc... have been deducted.")
  public ActiveOrHistoricCurrencyAndAmount getConfirmedAmount() {
    return confirmedAmount;
  }

  public void setConfirmedAmount(ActiveOrHistoricCurrencyAndAmount confirmedAmount) {
    this.confirmedAmount = confirmedAmount;
  }

  public PaymentTransaction75 paymentEvent(List<PaymentEvent6> paymentEvent) {
    this.paymentEvent = paymentEvent;
    return this;
  }

  public PaymentTransaction75 addPaymentEventItem(PaymentEvent6 paymentEventItem) {
    this.paymentEvent.add(paymentEventItem);
    return this;
  }

   /**
   * This groups the information of an event, i.e., of a payment message or status confirmation update. It is repeated as many times as there are events to be returned.
   * @return paymentEvent
  **/
  @ApiModelProperty(required = true, value = "This groups the information of an event, i.e., of a payment message or status confirmation update. It is repeated as many times as there are events to be returned.")
  public List<PaymentEvent6> getPaymentEvent() {
    return paymentEvent;
  }

  public void setPaymentEvent(List<PaymentEvent6> paymentEvent) {
    this.paymentEvent = paymentEvent;
  }


  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    PaymentTransaction75 paymentTransaction75 = (PaymentTransaction75) o;
    return Objects.equals(this.uetr, paymentTransaction75.uetr) &&
        Objects.equals(this.transactionStatus, paymentTransaction75.transactionStatus) &&
        Objects.equals(this.eventTime, paymentTransaction75.eventTime) &&
        Objects.equals(this.originator, paymentTransaction75.originator) &&
        Objects.equals(this.instructedAmount, paymentTransaction75.instructedAmount) &&
        Objects.equals(this.confirmedAmount, paymentTransaction75.confirmedAmount) &&
        Objects.equals(this.paymentEvent, paymentTransaction75.paymentEvent);
  }

  @Override
  public int hashCode() {
    return Objects.hash(uetr, transactionStatus, eventTime, originator, instructedAmount, confirmedAmount, paymentEvent);
  }


  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class PaymentTransaction75 {\n");
    
    sb.append("    uetr: ").append(toIndentedString(uetr)).append("\n");
    sb.append("    transactionStatus: ").append(toIndentedString(transactionStatus)).append("\n");
    sb.append("    eventTime: ").append(toIndentedString(eventTime)).append("\n");
    sb.append("    originator: ").append(toIndentedString(originator)).append("\n");
    sb.append("    instructedAmount: ").append(toIndentedString(instructedAmount)).append("\n");
    sb.append("    confirmedAmount: ").append(toIndentedString(confirmedAmount)).append("\n");
    sb.append("    paymentEvent: ").append(toIndentedString(paymentEvent)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

}

